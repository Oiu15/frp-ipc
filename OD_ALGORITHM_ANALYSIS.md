# å¤–å¾„ï¼ˆODï¼‰è®¡ç®—ç®—æ³•è¯¦ç»†åˆ†æ

## æ‰§è¡Œæ‘˜è¦

æ‚¨é‡åˆ°çš„**æ‹Ÿåˆåç»“æœä¸ç¨³å®š**è€Œ**æ‹Ÿåˆå‰ï¼ˆmediané™é‡‡æ ·ï¼‰ç›¸å¯¹ç¨³å®š**çš„é—®é¢˜ï¼Œå¯èƒ½ç”±ä»¥ä¸‹å¤šä¸ªå› ç´ å…±åŒå¯¼è‡´ï¼š

1. **binæ–¹æ³•å¼•å…¥çš„ä¿¡æ¯æŸå¤±** - mediané™é‡‡æ ·ä¸¢å¼ƒäº†åŸå§‹åˆ†å¸ƒä¿¡æ¯
2. **åœ†æ‹Ÿåˆæœ¬èº«çš„æ•°å€¼æ•æ„Ÿæ€§** - åŸºäºæœ€å°äºŒä¹˜æ³•å¯¹å¼‚å¸¸æ ·æœ¬æ•æ„Ÿ
3. **od_delta DCåç½®çš„ä¸å®Œå…¨å»é™¤** - è™½ç„¶ä»£ç å·²åšå¤„ç†ï¼Œä½†ä»å¯èƒ½ä¸å¤Ÿ
4. **åˆæˆç‚¹çš„å‡ ä½•é…å¯¹é—®é¢˜** - è¾¹ç•Œç‚¹å¯¹çš„ç”Ÿæˆæ–¹å¼å¯¼è‡´çš„"è™šæ‹Ÿ"å‡ ä½•ç»“æ„
5. **è§’åº¦å»¶è¿Ÿå‚æ•°æœªæ­£ç¡®é…ç½®** - å¦‚æœtheta_delay_sä¸ä¸º0ï¼Œå¯èƒ½ç ´åé‡‡æ ·ä¸€è‡´æ€§
6. **è‡ªé€‚åº”binæ•°çš„æ•´æ•°èˆå…¥** - bin_countåœ¨æ ·æœ¬ä¸è¶³æ—¶è‡ªåŠ¨ä¸‹è°ƒå¯¼è‡´ç‰¹å¾ä¸¢å¤±

---

## ç¬¬ä¸€éƒ¨åˆ†ï¼šç®—æ³•æµç¨‹è§£æ

### 1. æ•°æ®è·å–é˜¶æ®µ

```
åŸå§‹æ•°æ® (æ¯ä¸ªæ ·æœ¬):
  - theta_deg: æ—‹è½¬è§’åº¦ [0, 360)
  - ts: æ—¶é—´æˆ³
  - od_mm: å¤–å¾„æµ‹é‡å€¼ (ç›´å¾„å½¢å¼)
  - od_delta: å·¦å³è¾¹ç¼˜åå·® = (L - R) / 2 (ä»…æ–°ç®—æ³•)
```

### 2. é‡é‡‡æ ·ç­–ç•¥ï¼ˆbinæ–¹æ³•ï¼‰

#### ç­–ç•¥A: åŸå§‹æ¨¡å¼ (calc_input_mode="raw")

```python
for æ¯ä¸ªåŸå§‹æ ·æœ¬:
    r_right = od_mm/2 + od_delta    # å³è¾¹ç¼˜åŠå¾„
    r_left = od_mm/2 - od_delta     # å·¦è¾¹ç¼˜åŠå¾„
    ç”Ÿæˆ2ä¸ªåœ†å‘¨è¾¹ç•Œç‚¹: (r_right, theta), (-r_left, theta)
```

**ç‰¹ç‚¹**: 
- âœ“ ä¿ç•™æ‰€æœ‰åŸå§‹ä¿¡æ¯
- âœ— å¯¹æµ‹å¾„ä»ªå™ªå£°/å¼‚å¸¸æ•æ„Ÿ
- âœ— ç‚¹çš„åˆ†å¸ƒä¸å‡ï¼ˆå–å†³äºæ—‹è½¬é€Ÿåº¦å˜åŒ–ï¼‰

#### ç­–ç•¥B: Binæ¨¡å¼ (calc_input_mode="bin") â† **å½“å‰æ¨èç­–ç•¥**

```python
# æ­¥éª¤1: æŒ‰è§’åº¦åˆ†bin (é»˜è®¤bin_count=90)
for æ¯ä¸ªåŸå§‹æ ·æœ¬:
    bin_idx = (theta_deg / 360.0) * bin_count  # é‡åŒ–åˆ°[0, bin_count)
    rr_bins[bin_idx].append(od_mm/2 + od_delta)
    rl_bins[bin_idx].append(od_mm/2 - od_delta)

# æ­¥éª¤2: å¯¹æ¯ä¸ªbinåšé™é‡‡æ · (median/mean)
for bin_idx in 1..bin_count:
    if binæœ‰æ ·æœ¬:
        rr_reduced = median(rr_bins[bin_idx])  # æˆ–mean
        rl_reduced = median(rl_bins[bin_idx])
        ç”Ÿæˆ2ä¸ªåˆæˆè¾¹ç•Œç‚¹äºbinä¸­å¿ƒè§’åº¦

# æ­¥éª¤3: è‡ªé€‚åº”binè°ƒæ•´
å®é™…binæ•° = min(bin_count, n_samples // 2)
```

**è¿™æ˜¯é€ æˆæ‚¨è§‚å¯Ÿåˆ°ç°è±¡çš„å…³é”®**ï¼š
1. **mediané™é‡‡æ ·** ç¡®å®ç¨³å®šäº†æ•°æ®ï¼ˆæŠ—å¼‚å¸¸èƒ½åŠ›å¼ºï¼‰
2. **ä½†åŒæ—¶ä¸§å¤±äº†åˆ†å¸ƒä¿¡æ¯** - æ¯ä¸ªbinåªå‰©1ä¸ªä»£è¡¨å€¼è€Œé2ä¸ª
3. **æ‹Ÿåˆæ—¶å¼•å…¥çš„åå·®** - åˆæˆçš„"æ¼‚äº®"ç‚¹äº‘åè€Œå¯¼è‡´æ‹Ÿåˆç»“æœå¯¹åˆå§‹æ¡ä»¶æ•æ„Ÿ

### 3. DCåç½®å»é™¤ï¼ˆod_deltaçš„å¤„ç†ï¼‰

```python
# è®¡ç®—od_deltaçš„ä¸­ä½æ•°åç½®
dlt_bias = median(od_delta)

# å»é™¤åç½®
for æ¯ä¸ªæ ·æœ¬:
    r_right = od_mm/2 + (od_delta - dlt_bias)  # ç›¸å¯¹åå·®
    r_left = od_mm/2 - (od_delta - dlt_bias)
```

**æ„ä¹‰**ï¼š
- å¦‚æœæµ‹å¾„ä»ªæœ‰ç³»ç»Ÿçš„ä¼ æ„Ÿå™¨å®‰è£…åå·®ï¼Œç›´æ¥å¯¼è‡´od_deltaçš„æ’å®šåç§»
- å»é™¤åå¯ä»¥åªä¿ç•™çœŸå®çš„ç¦»å¿ƒç‡ä¿¡æ¯
- **ä½†è¿™é‡Œçš„é—®é¢˜**ï¼šmedianåªæ˜¯statisticalä¸­ä½æ•°ï¼Œä¸ä¸€å®šæ˜¯"çœŸæ­£çš„"ç³»ç»Ÿåç½®

### 4. åœ†æ‹Ÿåˆé˜¶æ®µ

```python
# ç”Ÿæˆçš„ç‚¹é›† (Cartesianåæ ‡)
coords = [(r*cos(theta), r*sin(theta)) for (r, theta) in pts]

# è°ƒç”¨ _fit_circle(coords)
# ä½¿ç”¨åŠ æƒä»£æ•°æœ€å°äºŒä¹˜ (KÃ¥saæ–¹æ³•)
A = [2*x, 2*y, 1]
target = xÂ² + yÂ²
æ±‚è§£: (xc, yc, c) via lstsq

æ‹Ÿåˆåœ†: (x-xc)Â² + (y-yc)Â² = RÂ²
å…¶ä¸­ R = sqrt(c + xcÂ² + ycÂ²)
```

**æ•°å€¼ç‰¹æ€§**ï¼š
- ä»£æ•°æœ€å°äºŒä¹˜å¯¹**ç‚¹çš„æƒé‡åˆ†å¸ƒ**æ•æ„Ÿ
- å¦‚æœç‚¹äº‘åˆ†å¸ƒä¸å‡ï¼ˆå¦‚æŸäº›binç¼ºå¤±ï¼‰ï¼Œæ‹Ÿåˆä¸­å¿ƒåç§»
- æ‹Ÿåˆæ®‹å·® `e = radius - R_fit` å†³å®šäº†"çœŸåœ†åº¦"

### 5. çœŸåœ†åº¦è®¡ç®—

```python
# è®¡ç®—æ¯ç‚¹åˆ°æ‹Ÿåˆåœ†å¿ƒçš„è·ç¦»è¯¯å·®
e_i = sqrt((x_i - xc)Â² + (y_i - yc)Â²) - R_fit

# ä¸¥æ ¼p-p (strict peak-to-peak)
od_round_fit_mm = 2 * (max(e) - min(e))

# é²æ£’p-p (p99-p1 ç™¾åˆ†ä½)
od_round_fit_rob_mm = 2 * (percentile(e, 99) - percentile(e, 1))
```

---

## ç¬¬äºŒéƒ¨åˆ†ï¼šé—®é¢˜è¯Šæ–­

### é—®é¢˜ç°è±¡

| æŒ‡æ ‡         | æ‹Ÿåˆå‰(mediané™é‡‡æ ·) | æ‹Ÿåˆå        |
|------------|-----------|----------|
| å¤ç°ç‡        | è¾ƒé«˜â‰¥85%   | ä½<50%   |
| å˜å¼‚ç³»æ•°(CV)  | ~5-10%    | ~15-25% |
| è¶‹åŠ¿æ€§       | ç¨³å®š       | è·³è·ƒ/æŒ¯è¡ |

### é—®é¢˜åŸå› é“¾åˆ†æ

#### åŸå› 1ï¸âƒ£: Binè¾¹ç•Œæ•ˆåº” 

```
é—®é¢˜: æŸä¸ªbinçš„æ ·æœ¬æ•°è¿‡å°‘æˆ–ä¸å‡
     
èŒƒä¾‹:
  Bin-0 (0Â°-4Â°):      5ä¸ªæ ·æœ¬ â†’ medianå€¼
  Bin-1 (4Â°-8Â°):     20ä¸ªæ ·æœ¬ â†’ medianå€¼
  Bin-2 (8Â°-12Â°):     2ä¸ªæ ·æœ¬ â†’ medianå€¼ âš ï¸ åªæœ‰2ä¸ª,æ˜“è¢«å™ªå£°ä¸»å¯¼
  
ç»“æœ: æ‹Ÿåˆæ—¶Bin-2çš„ç‚¹åç¦»çœŸå®è½¨è¿¹
```

**å¤ç°æ€§ç ´å**ï¼š
- åç»­é‡‡æ ·æ—¶ï¼ŒBin-2çš„æ ·æœ¬å¯èƒ½æ˜¯ä¸åŒçš„2ä¸ªï¼Œå¯¼è‡´medianå€¼å®Œå…¨ä¸åŒ
- è™½ç„¶median(5ä¸ªæ•°æ®)ç›¸å¯¹ç¨³å®šï¼Œä½†median(2ä¸ªæ•°æ®)ææ˜“æ³¢åŠ¨

#### åŸå› 2ï¸âƒ£: è‡ªé€‚åº”binè®¡æ•°é€»è¾‘

```python
def _adaptive_bin_count(requested: int, n_samples: int):
    cap = max(3, n_samples // 2)
    return min(requested, cap)
    
ç¤ºä¾‹:
  requested=90, n_samples=100
  â†’ actual_bin_count = min(90, 50) = 50 âŒ 
  
  requested=90, n_samples=200  
  â†’ actual_bin_count = min(90, 100) = 90 âœ“
```

**å½±å“**ï¼š
- å½“æ ·æœ¬æ•°ä¸ç¨³å®šæ—¶ï¼Œbinæ•°é‡å˜åŒ–
- binæ•°é‡å˜ â†’ æ¯ä¸ªbinçš„æ ·æœ¬æ•°é‡æ–°åˆ†é… â†’ medianå€¼æ”¹å˜
- **å¯¼è‡´æ‹Ÿåˆç»“æœéçº¿æ€§å˜åŒ–**

#### åŸå› 3ï¸âƒ£: åˆæˆç‚¹å¯¹çš„å¯¹ç§°æ€§å‡è®¾

```
å½“å‰åšæ³•:
  ç”Ÿæˆç‚¹å¯¹: (r_right*cos(Î¸), r_right*sin(Î¸)) 
           + (-r_left*cos(Î¸), -r_left*sin(Î¸))
           
è¿™å‡è®¾äº†çœŸå®å¤–åœ†æ˜¯å®Œå…¨å…³äºåŸç‚¹å¯¹ç§°çš„!

ä½†å®é™…:
  - æµ‹å¾„ä»ªæµ‹é‡çš„od_mmæœ¬èº«å¯èƒ½æœ‰åå·®æ¢¯åº¦
  - od_delta(ç¦»å¿ƒç‡)ä¸æ˜¯å®Œå…¨æ­£å¼¦æ›²çº¿
  - åŸç‚¹(0,0)å¯èƒ½ä¸å¯¹åº”çœŸå®æ—‹è½¬ä¸­å¿ƒ
```

**æ•°å€¼åæœ**ï¼š
- å¼ºè¡Œæ„é€ çš„å¯¹ç§°ç‚¹å¯¹ â†’ æ‹Ÿåˆåœ†è¢«è¿«é€šè¿‡åŸç‚¹é™„è¿‘
- å¦‚æœçœŸå®åœ†å¿ƒåç¦»åŸç‚¹ï¼Œæ‹Ÿåˆæ®‹å·®å‰§å¢
- å¾®å°æ ·æœ¬æ³¢åŠ¨ â†’ æ‹Ÿåˆä¸­å¿ƒæ‘†åŠ¨å¤§ â†’ æ®‹å·®å˜åŒ–å¤§

#### åŸå› 4ï¸âƒ£: DCåç½®å»é™¤çš„ä¸å®Œå…¨æ€§

```python
å½“å‰ä»£ç :
dlt_bias = median(od_delta)  # å•ä¸€ä¸­ä½æ•°

é—®é¢˜:
  å¦‚æœod_deltaéšthetaæœ‰ç¼“å˜çš„äºŒé˜¶é¡¹:
    od_delta(Î¸) = offset + A*cos(Î¸) + B*sin(Î¸) + noise
    
  åˆ™medianåªèƒ½å»é™¤"offset"ï¼Œä¿ç•™çš„(A,B)é¡¹è¢«é”™è¯¯åœ°å† ä»¥
  "ç¦»å¿ƒç‡"çš„åä¹‰ï¼Œå…¶å®æ˜¯æµ‹å¾„ä»ªçš„äºŒé˜¶è¯¯å·®!
```

**å½±å“å¤ç°ç‡**ï¼š
- è‹¥äºŒé˜¶è¯¯å·®åœ¨ä¸åŒé‡‡æ ·ä¸­é¢‘æ¬¡ä¸åŒï¼Œå¯¼è‡´æ‹Ÿåˆç»“æœå·®å¼‚

#### åŸå› 5ï¸âƒ£: è§’åº¦å»¶è¿Ÿè¡¥å¿çš„æ½œåœ¨é”™è¯¯

```python
if abs(theta_delay_s) > 1e-9:
    omega = _estimate_omega_deg_s(theta_list, ts_list)
    # çº¿æ€§æ‹Ÿåˆ Î¸ = Î¸0 + Ï‰*t
    theta_corr = theta_deg + omega * theta_delay_s
```

**é—®é¢˜**ï¼š
- å¦‚æœæ—‹è½¬è§’é€Ÿåº¦Ï‰æœ¬èº«åœ¨å˜åŒ–ï¼ˆacceleration/decelerationï¼‰å‘¢ï¼Ÿ
- çº¿æ€§å¤–æ¨ â†’ theta_corrå¯èƒ½åç¦»çœŸå®å€¼ â† **é‡‡æ ·ç‚¹ä½ç½®é”™ä½**
- é”™ä½çš„ç‚¹äº‘ â†’ æ‹Ÿåˆåœ†å˜åŒ–

---

## ç¬¬ä¸‰éƒ¨åˆ†ï¼šæ•°æ®å¤ç°ç‡ä½çš„å…·ä½“å› ç´ æ’åº

æ ¹æ®å½±å“ç¨‹åº¦ï¼ˆé«˜â†’ä½ï¼‰ï¼š

### ğŸ”´ é«˜å½±å“ï¼ˆç›´æ¥ç ´åç¨³å®šæ€§ï¼‰

1. **Binç²’åº¦ä¸æ ·æœ¬åˆ†å¸ƒä¸åŒ¹é…** (æƒé‡: 40%)
   - æŸäº›binæ ·æœ¬è¿‡å°‘(<3), medianä¸ç¨³å®š
   - è‡ªé€‚åº”binæ•°ä½¿ä¸åŒè¿è¡Œä¹‹é—´binæ•°é‡å˜åŒ–

2. **åˆæˆå¯¹ç§°ç‚¹å¯¹çš„è™šæ‹Ÿå‡ ä½•** (æƒé‡: 30%)
   - å¼ºåˆ¶å¯¹ç§°å¯¼è‡´çš„"äººå·¥ç»“æ„"ä½¿æ‹Ÿåˆå¯¹å¼‚å¸¸æ ·æœ¬æ•æ„Ÿ
   - çœŸå®ç¦»å¿ƒç‡æ›²çº¿å¯èƒ½éå¯¹ç§°

### ğŸŸ¡ ä¸­å½±å“ï¼ˆæ¡ä»¶æ€§ç ´åï¼‰

3. **od_deltaçš„DCåç½®å»é™¤æœºåˆ¶** (æƒé‡: 20%)
   - ä»…å»é™¤ä¸€é˜¶(median)åç½®ï¼Œé«˜é˜¶è¯¯å·®æ®‹ç•™
   - ä¸åŒé‡‡æ ·æ¡ä»¶ä¸‹äºŒé˜¶é¡¹å¹…åº¦å¯èƒ½å˜åŒ–

4. **åœ†æ‹Ÿåˆæ–¹æ³•çš„æ•°å€¼æ¡ä»¶æ•°** (æƒé‡: 5%)
   - KÃ¥saæœ€å°äºŒä¹˜å¯¹ç‚¹åˆ†å¸ƒä¸å‡æ•æ„Ÿ
   - ä½†è¿™æ˜¯åœ†æ‹Ÿåˆçš„é€šç”¨é—®é¢˜

### ğŸŸ¢ ä½å½±å“ï¼ˆç¨³å®šæ€§å¹²æ‰°)

5. **è§’åº¦å»¶è¿Ÿè¡¥å¿** (æƒé‡: 3%)
   - ä»…åœ¨é…ç½®äº†theta_delay_sæ—¶æ‰è§¦å‘
   - å½±å“é€šå¸¸æœ‰æ–¹å‘æ€§ï¼ˆç³»ç»Ÿæ€§æ¼‚ç§»ï¼‰

6. **æ•°å€¼ç²¾åº¦** (æƒé‡: 2%)
   - ç°ä»£æµ®ç‚¹è¿ç®—ç²¾åº¦è¶³å¤Ÿï¼Œé™¤éæœ‰æç«¯æ¡ä»¶

---

## ç¬¬å››éƒ¨åˆ†ï¼šå»ºè®®è¯Šæ–­æ–¹æ¡ˆ

### å¿«é€Ÿè¯„ä¼° (å¿…åš)

**é—®é¢˜1: Binç²’åº¦æ˜¯å¦è¿‡ç²—ï¼Ÿ**

```python
# åœ¨ _od_round_fit_from_raw_points() åæ·»åŠ è¯Šæ–­æ—¥å¿—
print(f"æ ·æœ¬æ€»æ•°: {len(th_list)}")
print(f"éç©ºbinæ•°: {used}")
print(f"æ¯binå¹³å‡æ ·æœ¬æ•°: {len(th_list) / used:.1f}")

if len(th_list) / used < 4:
    print("âš ï¸  WARNING: Binå¹³å‡æ ·æœ¬è¿‡å°‘, å»ºè®®bin_counté™ä½è‡³20-30")
```

**é—®é¢˜2: æ˜¯å¦å­˜åœ¨ç¨€ç–binï¼Ÿ**

```python
# åœ¨build binåæ£€æŸ¥
for i, (rr_list, rl_list) in enumerate(zip(rr_bins, rl_bins)):
    if len(rr_list) == 1:
        print(f"âš ï¸  Bin-{i}: ä»…1ä¸ªæ ·æœ¬ (medianéš¾ä»¥ç¨³å®š)")
    if len(rr_list) >= 10:
        # è®¡ç®—è¯¥binå†…çš„å˜å¼‚ç³»æ•°
        cv = np.std(rr_list) / (np.mean(rr_list) + 1e-9)
        if cv > 0.1:
            print(f"âš ï¸  Bin-{i}: é«˜å˜å¼‚ç³»æ•°={cv:.3f}")
```

**é—®é¢˜3: æ˜¯å¦å­˜åœ¨od_deltaçš„ééšæœºåå·®ï¼Ÿ**

```python
# ç»˜åˆ¶ od_delta vs theta_degçš„åˆ†å¸ƒ
import matplotlib.pyplot as plt
plt.scatter(th_list, dlt_raw_list, alpha=0.5)
plt.axhline(y=dlt_bias, color='r', label=f'Median={dlt_bias:.4f}')
plt.xlabel('theta_deg')
plt.ylabel('od_delta')
plt.legend()
plt.show()

# æ£€æŸ¥æ˜¯å¦å­˜åœ¨äºŒé˜¶ç»“æ„:
# è‹¥æ•£ç‚¹å½¢æˆ"æ¤­åœ†"è€Œé"ç›´çº¿" â†’ å­˜åœ¨od_deltaçš„æ–¹å‘ä¾èµ–æ€§
```

### æ·±åº¦è¯Šæ–­ (è¿›é˜¶)

**å¯¹æ¯”æµ‹è¯•: Raw vs Bin**

```python
ç»“åˆcalc_input_mode="raw"è¿è¡Œä¸€æ¬¡é‡‡æ ·ï¼Œè®°å½•:
  - od_round_fit_mm (raw)
  - od_round_fit_rob_mm (raw)
  
ä¸binç»“æœå¯¹æ¯”:
  è‹¥rawç»“æœåè€Œä¸ç¨³å®š â†’ é—®é¢˜åœ¨åŸå§‹æ•°æ®å™ªå£°
  è‹¥rawç»“æœæ›´ç¨³å®š â†’ é—®é¢˜ç¡®å®åœ¨biné™é‡‡æ ·æ–¹æ³•
```

### é•¿æœŸæ”¹è¿›æ–¹æ¡ˆ

---

## ç¬¬äº”éƒ¨åˆ†ï¼šæ”¹è¿›å»ºè®®æ–¹æ¡ˆ

### æ–¹æ¡ˆA: å¢å¼ºBiné²æ£’æ€§ (æ¨èä¼˜å…ˆçº§: â˜…â˜…â˜…â˜…â˜…)

```python
def _od_round_fit_from_raw_points_v2(...):
    """æ”¹è¿›ç‰ˆ: å¯¹Binæ•°é‡/æ ·æœ¬åˆ†å¸ƒçš„è‡ªé€‚åº”ä¼˜åŒ–"""
    
    # 1. æ ·æœ¬é¢„æ£€æŸ¥
    if len(th_list) < 20:
        print(f"æ ·æœ¬è¿‡å°‘({len(th_list)}), è‡ªåŠ¨åˆ‡æ¢åˆ°rawæ¨¡å¼")
        mode = "raw"  # å¼ºåˆ¶åˆ‡æ¢
        
    # 2. æ™ºèƒ½Binè°ƒæ•´
    if mode.startswith("bin"):
        # ä¸ç”¨ç®€å•çš„n_samples//2ï¼Œç”¨æ›´ä¿å®ˆçš„ä¼°è®¡
        min_samples_per_bin = 5  # è¦æ±‚æ¯binâ‰¥5ä¸ªæ ·æœ¬
        adaptive_bin = max(3, len(th_list) // min_samples_per_bin)
        bin_count = min(requested_bin_count, adaptive_bin)
        
        # æ£€æŸ¥å®é™…åˆ†å¸ƒ
        bin_load = [len(bins[i]) for i in range(bin_count)]
        sparse_bins = sum(1 for load in bin_load if load < 3)
        if sparse_bins > bin_count * 0.2:  # >20%çš„binæ ·æœ¬è¿‡å°‘
            bin_count = bin_count // 2  # è¿›ä¸€æ­¥é™ä½
            
    # 3. Binå†…å¼‚å¸¸å€¼è¿‡æ»¤ (Optional)
    for i in range(bin_count):
        if len(rr_bins[i]) >= 3:
            # IQRæ³•å¼‚å¸¸å€¼æ£€æµ‹
            q1, q3 = np.percentile(rr_bins[i], [25, 75])
            iqr = q3 - q1
            mask = (rr_bins[i] >= q1-1.5*iqr) & (rr_bins[i] <= q3+1.5*iqr)
            rr_bins[i] = [v for v, m in zip(rr_bins[i], mask) if m]
            
    return od_round_fit_mm, od_round_fit_rob_mm
```

### æ–¹æ¡ˆB: æ”¹è¿›od_deltaå¤„ç† (ä¼˜å…ˆçº§: â˜…â˜…â˜…â˜†â˜†)

```python
def remove_od_delta_bias_v2(dlt_raw_list, th_list):
    """æ”¹è¿›: ä½¿ç”¨2DOFæ­£å¼¦æ‹Ÿåˆè€Œéç®€å•median"""
    
    dlt_arr = np.asarray(dlt_raw_list, dtype=float)
    th_arr = np.asarray(th_list, dtype=float)
    th_rad = np.deg2rad(th_arr)
    
    # æ‹Ÿåˆ: dlt = offset + A*cos(th) + B*sin(th)
    A_fit = np.column_stack([
        np.ones_like(th_rad),
        np.cos(th_rad),
        np.sin(th_rad)
    ])
    coef, _, _, _ = np.linalg.lstsq(A_fit, dlt_arr, rcond=None)
    offset, A, B = coef
    
    # å»é™¤offsetå’Œä½é¢‘é¡¹(å¯é€‰)
    dlt_corrected = dlt_arr - offset  # ä¿ç•™A*cos + B*sin
    # æˆ–æ›´æ¿€è¿›: dlt_corrected = dlt_arr - offset - A*cos(th) - B*sin(th)
    
    return dlt_corrected
```

### æ–¹æ¡ˆC: ä½¿ç”¨åŠ æƒåœ†æ‹Ÿåˆ (ä¼˜å…ˆçº§: â˜…â˜…â˜†â˜†â˜†)

```python
def _od_round_fit_from_raw_points_v3_weighted(...):
    """ä½¿ç”¨åŸºäºæ ·æœ¬è®¡æ•°çš„æƒé‡ï¼Œpenalizeæ¥è‡ªç¨€ç–binçš„ç‚¹"""
    
    # ç”Ÿæˆç‚¹æ—¶ï¼Œè®°å½•æ¯ç‚¹æ¥è‡ªçš„binå¤§å°
    weights = []
    for (r, theta) in pts:
        bin_idx = ...
        bin_size = len(rr_bins[bin_idx])
        weight = np.log1p(bin_size)  # log(bin_size)ä½œä¸ºæƒé‡
        weights.append(weight)
    
    # è°ƒç”¨åŠ æƒåœ†æ‹Ÿåˆ
    weights = np.asarray(weights, dtype=float)
    xc, yc, r_fit, sigma = self._fit_circle(coords, weights=weights)
    
    # åç»­è®¡ç®—ä¸ä¹‹å‰ç›¸åŒ
```

### æ–¹æ¡ˆD: åˆ†é˜¶æ®µè´¨é‡è¯„ä¼° (ä¼˜å…ˆçº§: â˜…â˜…â˜…â˜†â˜†)

```python
# åœ¨æ‹Ÿåˆå‰æ·»åŠ è´¨é‡æ£€æŸ¥
def assess_od_fitting_quality(th_list, dlt_raw_list, rr_bins, rl_bins):
    """è¿”å›ä¸€ä¸ª0-1çš„è´¨é‡åˆ†æ•°"""
    
    scores = {
        "sample_count": min(1.0, len(th_list) / 100),  # 100ä¸ªæ ·æœ¬ä¸ºæ»¡åˆ†
        "bin_fullness": 1.0 - (sparse_bin_count / total_bins),  # éç©ºbinæ¯”ä¾‹
        "sample_per_bin": min(1.0, avg_samples_per_bin / 5),   # æ¯binâ‰¥5ä¸ºæ»¡åˆ†
        "delta_consistency": assess_delta_coherence(dlt_raw_list),  # æ£€æŸ¥od_deltaçš„ä¸€è‡´æ€§
    }
    
    # åŠ æƒå¹³å‡
    quality = (
        0.3 * scores["sample_count"] +
        0.3 * scores["bin_fullness"] +
        0.2 * scores["sample_per_bin"] +
        0.2 * scores["delta_consistency"]
    )
    
    if quality < 0.6:
        print(f"âš ï¸  ODæ‹Ÿåˆè´¨é‡ä½({quality:.2%}), ç»“æœå»ºè®®å¤æ ¸")
        # å¯æ ‡è®°ä¸º"éœ€è¦é‡æ–°é‡‡æ ·"
    
    return quality
```

---

## ç¬¬å…­éƒ¨åˆ†ï¼šå‚æ•°è°ƒä¼˜æŒ‡å—

### å½“å‰é…ç½®

| å‚æ•°              | å€¼   | å¯¹å¤ç°ç‡å½±å“ |
|------------------|------|----------|
| calc_input_mode  | "bin"| é«˜       |
| bin_count        | 90   | é«˜       |
| bin_method       | "median" | ä¸­   |
| pp_mode          | "p99_p1" | ä¸­   |

### å¦‚ä½•è°ƒä¼˜

#### ğŸ¯ åœºæ™¯1: æ ·æœ¬æ•°ä¸ç¨³å®š (50-200ä¸ª/åœˆ)

```yaml
å»ºè®®é…ç½®:
  calc_input_mode: "bin"          # ä¿æŒbin
  bin_count: 20-30                # é™ä½! (ä»90â†’30)
  bin_method: "median"            # ä¿æŒä¸­å€¼(é˜²å™ªå£°)
  pp_mode: "p99_p1"               # ä¿æŒé²æ£’è·¨åº¦

ç†ç”±:
  - æ ·æœ¬å°‘ â†’ biné¢—ç²’å¤§ â†’ æ¯binå¹³å‡5-10ä¸ªæ ·æœ¬ âœ“
  - 20ä¸ªbinçš„median(5ä¸ª)æ¯”90ä¸ªbinçš„median(0.5ä¸ª)ç¨³å®šå¾—å¤š
```

#### ğŸ¯ åœºæ™¯2: æ ·æœ¬æ•°ç¨³å®šå……è¶³ (>500ä¸ª/åœˆ)

```yaml
å»ºè®®é…ç½®:
  calc_input_mode: "raw"          # åˆ‡æ¢åˆ°åŸå§‹æ¨¡å¼
  bin_count: å¿½ç•¥
  bin_method: å¿½ç•¥
  pp_mode: "p99_p1"               # ä¿æŒé²æ£’

ç†ç”±:
  - æ ·æœ¬å¤š â†’ åŸå§‹æ¨¡å¼ä¸‹å™ªå£°è¢«å¹³å‡ âœ“
  - é¿å…äº†medianå¸¦æ¥çš„ä¿¡æ¯ä¸¢å¤± âœ“
  - æ‹Ÿåˆç»“æœä¼šä¿ç•™çœŸå®çš„åˆ†å¸ƒç‰¹å¾
```

#### ğŸ¯ åœºæ™¯3: é«˜å™ªå£°ç¯å¢ƒ

```yaml
å»ºè®®é…ç½®:
  calc_input_mode: "bin"
  bin_count: 20                   # æ›´ä½
  bin_method: "median"            # å¿…é¡»ä¸­å€¼
  pp_mode: "trim_0.05"            # æ”¹ä¸ºæ›´æ¿€è¿›çš„trim (è€Œép99_p1)

ç†ç”±:
  - æ›´ä½çš„bin_count + medianå¼ºç»„åˆ â†’ å¼‚å¸¸å€¼å¾ˆéš¾survival
  - trim_0.05æ¯”p99_p1æ›´æ¿€è¿›åœ°å‰”é™¤æå€¼
```

---

## ç¬¬ä¸ƒéƒ¨åˆ†ï¼šéªŒè¯æ–¹æ³•

### éªŒè¯1: é‡å¤é‡‡æ ·ä¸€è‡´æ€§

```python
# åœ¨åŒä¸€ç‰©ä½“ä¸Šé‡å¤é‡‡æ ·5æ¬¡ï¼Œè®°å½•æ¯æ¬¡çš„:
# - od_avg, od_round, od_round_fit

results = []
for trial in range(5):
    # é‡‡æ ·ç¬¬iæˆªé¢
    result = autoflow.measure_section(i)
    results.append({
        'od_avg': result.od_avg,
        'od_round_fit': result.od_round_fit_mm,
    })

# è®¡ç®—å˜å¼‚ç³»æ•° (CV = std / mean)
cv = np.std([r['od_round_fit'] for r in results]) / \
     np.mean([r['od_round_fit'] for r in results])
    
print(f"çœŸåœ†åº¦çš„CV = {cv:.2%}")
# æœŸæœ›: CV < 5% ä¸º"ç¨³å®š"
#      CV 5-10% ä¸º"ä¸€èˆ¬"  
#      CV > 10% ä¸º"ä¸ç¨³å®š"
```

### éªŒè¯2: Sample Sizeçš„å½±å“

```python
# ä¿®æ”¹é‡‡æ ·å‚æ•°ï¼Œä½¿åŒä¸€æˆªé¢çš„é‡‡æ ·ç‚¹æ•°ä¸åŒ:
# é…ç½®A: å¿«é€Ÿæ‰«(ä½ç‚¹æ•°) vs é…ç½®B: æ…¢é€Ÿæ‰«(é«˜ç‚¹æ•°)

# åˆ†åˆ«è¿è¡Œå¹¶å¯¹æ¯”ç»“æœå·®å¼‚
delta_od_avg = abs(result_A['od_avg'] - result_B['od_avg'])
delta_od_round = abs(result_A['od_round_fit'] - result_B['od_round_fit'])

print(f"å¹³å‡ç›´å¾„å·®: {delta_od_avg:.3f} mm (æœŸæœ› <0.1mm)")
print(f"çœŸåœ†åº¦å·®:   {delta_od_round:.3f} mm (æœŸæœ› <0.05mm)")

# è‹¥delta_od_roundå¾ˆå¤§ â†’ ç¡®è®¤é—®é¢˜åœ¨æ‹Ÿåˆ, è€ŒéåŸå§‹æµ‹é‡
```

### éªŒè¯3: ç®—æ³•æ¨¡å¼å¯¹æ¯”

```python
# åŒä¸€æ¬¡é‡‡æ ·ï¼Œåˆ†åˆ«ç”¨ä¸åŒç®—æ³•å¤„ç†:
mode_raw = _od_round_fit_from_raw_points(..., calc_input_mode="raw")
mode_bin  = _od_round_fit_from_raw_points(..., calc_input_mode="bin")

print(f"Rawæ¨¡å¼:   {mode_raw[1]} mm (é²æ£’)")
print(f"Binæ¨¡å¼:   {mode_bin[1]} mm (é²æ£’)")

# è‹¥rawæ˜æ˜¾åç¦»binä¸”æ›´ç¨³å®š â†’ binæ–¹æ³•æœ‰é—®é¢˜
# è‹¥twoéƒ½ä¸ç¨³å®š â†’ é—®é¢˜åœ¨åœ†æ‹Ÿåˆæœ¬èº«æˆ–åŸå§‹æ•°æ®
```

---

## æ€»ç»“ä¸è¡ŒåŠ¨æ¸…å•

### ğŸ” ç«‹å³è¯Šæ–­ (ä»Šå¤©)

- [ ] å¯ç”¨binæ ·æœ¬è®¡æ•°è¯Šæ–­æ—¥å¿—ï¼Œæ£€æŸ¥æ˜¯å¦æœ‰éç©ºbinæ•°<5çš„æƒ…å†µ
- [ ] ç»˜åˆ¶od_deltaåˆ†å¸ƒå›¾ï¼Œè§‚å¯Ÿæ˜¯å¦å‘ˆç°"æ¤­åœ†"ç»“æ„(äºŒé˜¶é¡¹)
- [ ] è°ƒæ•´bin_countä»90â†’30ï¼Œé‡æ–°åšä¸€æ¬¡é‡‡æ ·å¯¹æ¯”

### ğŸ”§ å¿«é€Ÿæ”¹è¿› (æœ¬å‘¨)

- [ ] å®ç°æ–¹æ¡ˆA:æ”¹è¿›Binæ ·æœ¬æ£€æŸ¥é€»è¾‘
- [ ] æ ¹æ®æ ·æœ¬é‡è‡ªåŠ¨åˆ‡æ¢calc_input_mode ("raw" vs "bin")
- [ ] æ·»åŠ è´¨é‡è¯„åˆ†ç³»ç»Ÿï¼Œæ ‡è®°ä½è´¨é‡é‡‡æ ·

### ğŸ“Š ä¸­æœŸä¼˜åŒ– (æœ¬æœˆ)

- [ ] å®ç°æ–¹æ¡ˆB:od_deltaçš„2DOFå»å
- [ ] å»ºç«‹Binç²’åº¦vsæ ·æœ¬é‡çš„æŸ¥è¡¨æ¨èç³»ç»Ÿ
- [ ] å¢åŠ UIæ˜¾ç¤º"æ‹Ÿåˆè´¨é‡"æŒ‡ç¤º

### ğŸ¯ é•¿æœŸæ–¹å‘ (å­£åº¦)

- [ ] è€ƒè™‘æ›´å…ˆè¿›çš„åœ†æ‹Ÿåˆç®—æ³• (Taubin, Hyperfit)
- [ ] å»ºç«‹æ ·æœ¬è´¨é‡çš„åŠ¨æ€åé¦ˆæœºåˆ¶
- [ ] è®°å½•æ‰€æœ‰é‡‡æ ·æ•°æ®ï¼Œç”¨MLè¯†åˆ«"åé‡‡æ ·"æ¨¡å¼

